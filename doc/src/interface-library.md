# The PLEXIL Standard Interface Library {#interface-library}

\namespace PLEXIL
\addtogroup interface-library

The %PLEXIL Executive distribution includes the following interfaces.

## Prebuilt interfaces

The following interface adapters are built by default, and are
available to all PLEXIL applications.  Some can be disabled at
build configuration time.

\see getting-started.html#configure-options

### TimeAdapter {#TimeAdapter}

The *TimeAdapter* implements time lookups:

 + `Date Lookup time;` 
 
Both `LookupNow` and `LookupOnChange` with tolerances are implemented.
When used as part of an expression for a `StartCondition`,
`InvariantCondition`, `ExitCondition`, or `EndCondition`,
`LookupOnChange(time, tolerance)` schedules a wakeup for
the Executive at the current time plus the tolerance.

TimeAdapter uses standard POSIX time APIs for reading wall clock time
and scheduling wakeups.  Its interface XML element:

    <Adapter AdapterType="OSNativeTime"/>

\note If you do not wish to build the TimeAdapter, specify the
`--without-unix-time` option to `configure`.

### UtilityAdapter

The *UtilityAdapter* implements the following printing commands:

 + `Command print(...);`
   Prints the values of its arguments to standard output.

 + `Command pprint(...);`,
   Prints the values of its arguments, separated by spaces and
   followed by a newline, to standard output.

 + `String Command printToString(...);`
   Prints its arguments with `print` and returns the output as a String.

 + `String Command pprintToString(...);`
   Prints its arguments with `pprint` and returns the output as a String.

Its interface XML element:

    <Adapter AdapterType="Utility"/>

### Launcher

The *Launcher* allows one PLEXIL plan to start, monitor, and stop
other plans.  It implements these Commands:

 + `String Command StartPlan(String planName, String paramName, Any paramValue, ...);`

   Runs a plan under the control of another plan, passing any number
   of name-argument pairs to that plan.  Specifically:

   Loads the plan `planName` as a library (if not already loaded).
   
   Creates a `LibraryNodeCall` Node to wrap the plan, and generates a
   unique NodeId for it.  The wrapper Node looks like:

    <pre>
    <Node NodeType="LibraryNodeCall">
     <NodeId>planName_234</NodeId>
     <ExitCondition>Lookup(ExitPlan("planName_234"))</ExitCondition>
     <NodeBody>
      <LibraryNodeCall>
       <NodeId>planName</NodeId>
       <Alias>
        <NodeParameter>paramName</NodeParameter>
        paramValue
       </Alias>
      </LibraryNodeCall>
     </NodeBody>
    </Node>
    </pre>

   It then adds the wrapper Node as a new plan and runs it.

   The `StartPlan` command returns the NodeId of the wrapper Node.
   This NodeId is useful in the other Commands and Lookups provided by
   this adapter.
 
 + `Command ExitPlan(String rootNodeId);`
 
   Requests the root node named by `rootNodeId` to exit.  It does this
   by setting the value of the Lookup state `ExitPlan(rootNodeId)` to
   `true`.
   
Launcher implements these Lookups:

 + `String Lookup PlanState(String rootNodeId)` - Returns the current
   NodeState of the named root node as a String.  Returns *unknown* if
   `rootNodeId` does not name an active plan.

 + `String Lookup PlanOutcome(String rootNodeId)` - Returns the
   current NodeOutcome of the named root node as a String.  Returns
   *unknown* if `rootNodeId` does not name an active plan, or if
   `rootNodeId` exists but is not yet in `FINISHED` state.

 + `String Lookup PlanFailureType(String rootNodeId)` - Returns the
   current FailureType of the named root node as a String.  Returns
   *unknown* if `rootNodeId` does not name an active plan, if
   `rootNodeId` exists but is not yet in `FINISHED` state, or if
   `rootNodeId` finished with an outcome other than `FAILED` or
   `EXITED`.
   
 + `Boolean Lookup ExitPlan(String rootNodeId)` - Used to implement
   the `ExitCondition` of the wrapper Node generated by the
   `StartPlan` command.  It returns `true` if the `ExitPlan` command
   has been invoked for the named `rootNodeId`; in all other cases it
   returns *unknown*.

Launcher's interface XML element:

    <Adapter AdapterType="Launcher"/>

### PlanDebugListener {#PlanDebugListener}

The *PlanDebugListener* uses the debug message facility to optionally
print a message with a time stamp when any Node transitions into
either the `EXECUTING` or `FINISHED` states. 

The messages are disabled by default.  They can be enabled by adding
the line:

    :Node:clock

to the debug configuration file.

PlanDebugListener's interface XML element:

    <Listener ListenerType="PlanDebugListener"/>

If more selective output is desired, a listener filter can be added to
the configuration XML.

\note If you do not wish to build the PlanDebugListener, specify the
`--disable-debug-listener` option to `configure`.

### LuvListener {#LuvListener}

The *LuvListener* interfaces with the %PLEXIL Viewer, a visualization
application, to allow monitoring the execution of %PLEXIL plans in
real time.

LuvListener's interface XML allows for a number of options.  Not all
of them need to be provided.  And the `universalExec` application
allows specifying the necessary parameters on the command line.

The default values are shown in this example:

    <Listener ListenerType="LuvListener"
              HostName="localhost"
              Port="49100"
              Blocking="false"
              IgnoreConnectFailure="true" />

\note If you do not wish to build the LuvListener, specify the
`--disable-viewer` option to `configure`.

## Optional interfaces

The interface adapters below are optional.  They provide the
interfacing commands used by the Extended %PLEXIL `OnCommand` and
`OnMessage` compound nodes.

### IpcAdapter

The *IpcAdapter* implements inter-process communication via Carnegie
Mellon University's cross-platform 
[IPC](http://www.cs.cmu.edu/afs/cs/project/TCA/www/ipc/) 
package.

See [IpcAdapter](ipc-adapter.html) for more information.

### UdpAdapter

The *UdpAdapter* implements inter-process communication via UDP
datagrams.

See [UdpAdapter](udp-adapter.html) for more information.
