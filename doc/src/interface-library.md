# The PLEXIL Standard Interface Library {#interface-library}

\namespace PLEXIL
\addtogroup interface-library

The %PLEXIL Executive distribution includes the following interfaces.

## Prebuilt interfaces

The following interface adapters are built by default, and are
available to all PLEXIL applications.

### TimeAdapter

The *TimeAdapter* implements time lookups:

 + `Date Lookup time;` 
 
Both `LookupNow` and `LookupOnChange` with tolerances are implemented.
When used as part of an expression for a `StartCondition`,
`InvariantCondition`, `ExitCondition`, or `EndCondition`,
`LookupOnChange(time, tolerance)` schedules a wakeup for
the Executive at the current time plus the tolerance.

TimeAdapter uses standard POSIX time APIs for reading wall clock time
and scheduling wakeups.  Its interface XML element:

    <Adapter AdapterType="OSNativeTime"/>

\note If you do not wish to build the TimeAdapter, specify the
`--without-unix-time` option to `configure`.

### UtilityAdapter

The *UtilityAdapter* implements the following printing commands:

 + `Command print(...);`
   Prints the values of its arguments to standard output.

 + `Command pprint(...);`,
   Prints the values of its arguments, separated by spaces and
   followed by a newline, to standard output.

 + `String Command printToString(...);`
   Prints its arguments with `print` and returns the output as a String.

 + `String Command pprintToString(...);`
   Prints its arguments with `pprint` and returns the output as a String.

Its interface XML element:

    <Adapter AdapterType="Utility"/>

### Launcher

The *Launcher* allows one PLEXIL plan to start, monitor, and stop
other plans.  It implements these Commands:

 + `String Command StartPlan(String planName, String paramName, Any paramValue, ...);`

   Runs a plan under the control of another plan, passing any number
   of name-argument pairs to that plan.  Specifically:

   Loads the plan `planName` as a library (if not already loaded).
   
   Creates a `LibraryNodeCall` Node to wrap the plan, and generates a
   unique NodeId for it.  The wrapper Node looks like:

    <pre>
    <Node NodeType="LibraryNodeCall">
     <NodeId>planName_234</NodeId>
     <ExitCondition>Lookup(ExitPlan("planName_234"))</ExitCondition>
     <NodeBody>
      <LibraryNodeCall>
       <NodeId>planName</NodeId>
       <Alias>
        <NodeParameter>paramName</NodeParameter>
        paramValue
       </Alias>
      </LibraryNodeCall>
     </NodeBody>
    </Node>
    </pre>

   It then adds the wrapper Node as a new plan and runs it.

   The `StartPlan` command returns the NodeId of the wrapper Node.
   This NodeId is useful in the other Commands and Lookups provided by
   this adapter.
 
 + `Command ExitPlan(String rootNodeId);`
 
   Requests the root node named by `rootNodeId` to exit.  It does this
   by setting the value of the Lookup state `ExitPlan(rootNodeId)` to
   `true`.
   
Launcher implements these Lookups:

 + `String Lookup PlanState(String rootNodeId)` - Returns the current
   NodeState of the named root node as a String.  Returns *unknown* if
   `rootNodeId` does not name an active plan.

 + `String Lookup PlanOutcome(String rootNodeId)` - Returns the
   current NodeOutcome of the named root node as a String.  Returns
   *unknown* if `rootNodeId` does not name an active plan, or if
   `rootNodeId` exists but is not yet in `FINISHED` state.

 + `String Lookup PlanFailureType(String rootNodeId)` - Returns the
   current FailureType of the named root node as a String.  Returns
   *unknown* if `rootNodeId` does not name an active plan, if
   `rootNodeId` exists but is not yet in `FINISHED` state, or if
   `rootNodeId` finished with an outcome other than `FAILED` or
   `EXITED`.
   
 + `Boolean Lookup ExitPlan(String rootNodeId)` - Used to implement
   the `ExitCondition` of the wrapper Node generated by the
   `StartPlan` command.  It returns `true` if the `ExitPlan` command
   has been invoked for the named `rootNodeId`; in all other cases it
   returns *unknown*.

Launcher's interface XML element:

    <Adapter AdapterType="Launcher"/>

## Optional interfaces

The interface adapters below are optional.  They provide the
interfacing commands used by the Extended %PLEXIL `OnCommand` and
`OnMessage` compound nodes.

### IpcAdapter

The *IpcAdapter* implements inter-process communication via Carnegie
Mellon University's cross-platform 
[IPC](http://www.cs.cmu.edu/afs/cs/project/TCA/www/ipc/) 
package.

See [IpcAdapter](ipc-adapter.html) for more information.

### UdpAdapter

The *UdpAdapter* implements inter-process communication via UDP
datagrams.

See [UdpAdapter](udp-adapter.html) for more information.
