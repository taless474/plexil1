# Expressions in PLEXIL {#plexil-expressions}

mumble mumble generate values mumble mumble make nodes eligible for transition

## Expression evaluation

Every expression in %PLEXIL is expected to return a value.

A Command is *not* an expression. Not all commands return values.
Return values from commands can only be assigned to a variable.

### Expressions are strongly statically typed (mostly)

In general, expressions are strongly typed.  Exceptions are mostly
related to the `Any` type used in Lookup and Command declarations.
E.g. the `print` command provided by the UtilityAdapter.

There is currently no mechanism to determine, or specify, the return
or parameter types of Lookups and Commands with computed names.

The %PLEXIL Executive performs extensive type checking when a plan is
loaded, and will reject a plan with demonstrably inconsistent
expression types.  The Standard %PLEXIL compiler should catch and flag
most type errors.

### Evaluation order

In the Core %PLEXIL XML representation, expression evaluation proceeds
depth-first, with the subexpressions within each expression evaluated
by order of appearance.

The Standard %PLEXIL compiler implements traditional operator
precedence rules, derived from the C language standard.  The exact
order of evaluation can be inspected by looking at the Core %PLEXIL
XML generated by the compiler.

### The *unknown* value {#unknown}

A %PLEXIL expression whose value has not been established is said to
have the distinguished value *unknown*.  The *unknown* value cannot be
expressed as a literal in %PLEXIL.  It can be tested for with the
`isKnown`, `ALL_KNOWN`, and `ANY_KNOWN` predicates.

Any expression in %PLEXIL may evaluate to *unknown*.  In general, any
expression with an operand which evaluates to *unknown* is itself
*unknown*.  (There are exceptions, notably the Boolean operators `AND`
and `OR`, as we will see below.)

### Numeric expressions and type contagion

mumble mumble Integer Real etc

## Expressions available in PLEXIL

A %PLEXIL plan may contain these kinds of expressions.

### Literal values

In Core %PLEXIL, every literal value is represented as an XML element
whose name indicates the type of the literal: e.g. `BooleanValue`,
`IntegerValue,` `RealValue`, `StringValue`, `ArrayValue`, etc.  The
contents of the element are parsed as dictated by the element name.

In Standard %PLEXIL, the types of most literals can be deduced either
lexically (e.g. `true`, `FINISHED`, `"a string"`), or in the case of
ambiguities, from the context.  E.g. the literals `0` and `1` can have
`Boolean`, `Integer`, or `Real` type, depending on the context.

Type disambiguation of literal numbers in numerical expressions is
more difficult, and may yield unexpected behavior.  In this respect,
Standard %PLEXIL is no different than languages like C.  As a general
rule, use a decimal point if a literal number should be seen as a
`Real` by the compiler.

### Variable references

In Core %PLEXIL, a variable reference is an XML element with a
variable type name, whose content is the name of the variable.

In Standard %PLEXIL, a variable reference is simply the name of the
variable.

### Node variable references

To reference a Node's variable, first one must uniquely reference the
desired Node.  Plans can do this either via a *NodeRef* or by the
*NodeId*.

#### NodeRef

The NodeRef form is the more restrictive of the two.  NodeRef can
reference the Node itself, its parent, a named child Node, or a named
sibling Node.  It consists of an axis (self, parent, child, sibling),
and a name in the case of child or sibling axis.

Core %PLEXIL represents a NodeRef with the `NodeRef` element.  See the
%PLEXIL schema for specifics.

Standard %PLEXIL represents a NodeRef by the keywords `Self` or
`Parent`, or by the keywords `Child` or `Sibling` followed by the
(literal) name of the desired node in parentheses.  E.g. `Child(bar)`.

#### NodeId

The NodeId form is less work for the plan writer, and allows wider
access, but makes more work for the Executive at plan loading time,
and can be ambiguous.  To find the referenced Node, the plan loader
searches for the given name, starting with the referencing Node, then
its children, then its parent, then its siblings (parent's children),
then up the tree for a direct ancestor or the sibling of one, to the
root Node of the plan.

If more than one Node in this search path has the same NodeId, the
first matching Node along the search path will be found.

Core %PLEXIL represents the NodeId reference with the `NodeId`
element.

Standard %PLEXIL represents the NodeId with the literal name of the
node.

#### Node state, outcome, and failure type

Core %PLEXIL allows reading the state, outcome, and failure type of a
referenced node via the `NodeStateVariable`, `NodeOutcomeVariable`,
and `NodeFailureVariable` elements respectively.

Standard %PLEXIL uses the notation `.state`, `.outcome`, and
`.failure` following the node reference. E.g. `Foo.state`,
`Sibling(George).outcome`, `Child(Tom).failure`.

#### Node timepoint values

Whenever a Node changes state, the time of the state transition is
logged.  These *node timepoint values* are the wall clock time of the
transition, represented as a `Real` (or `Date` in Extended and
Standard %PLEXIL).

Each node state has a start and an end timepoint.  So a complete node
timepoint value reference consists of a node reference, a node state
name, and either start or end.

A node timepoint value reference for a state to which the Node has not
yet transitioned returns *unknown*.

In Core %PLEXIL, this is represented by the `NodeTimepointValue`
element.

In Standard %PLEXIL, the syntax is *noderef.state*.START or
*noderef.state*.END.  E.g. `Self.EXECUTING.START`, `Foo.FINISHED.START`,
`Child(Tom).EXECUTING.END`.

#### Command handle values

A `Command` node has a *command handle*, which represents the state of
the handshaking between the Executive and the external system.
Command handle references can be *unknown* if the Node has not yet
been executed, or if the external system has not yet acknowledged the
command.

Core %PLEXIL uses the `NodeCommandHandleVariable` element.

Standard %PLEXIL uses *noderef*.command_handle.

### Array element references

### Predicates

*Predicates* are functions of one argument which return a `Boolean`
value.

#### Predicates for general use

- `isKnown` returns `true` if its argument is known, `false` if its
  argument is *unknown*.  See below for more about *unknown*.
  `isKnown` always returns a known value.

#### Predicates on array values

- `ALL_KNOWN` returns `true` if every element of its array argument is
  known, `false` if any element is *unknown*.  `ALL_KNOWN` always
  returns a known value.
  
- `ANY_KNOWN` returns `true` if any element of its array argument is
  known, `false` if every element is *unknown*.  `ANY_KNOWN` always
  returns a known value.

#### Predicates on Node status

Predicates in this section take a Node reference parameter.  Node
state predicates always return either `true` or `false`, never
*unknown*.

Predicates on the state of a Node:

- `Inactive` - `true` if the referenced node is in `INACTIVE` state,
  `false` otherwise.

- `Waiting` - `true` if the referenced node is in `WAITING` state,
  `false` otherwise.

- `Executing` - `true` if the referenced node is in `EXECUTING` state,
  `false` otherwise.

- `IterationEnded` - `true` if the referenced node is in `ITERATION_ENDED` state,
  `false` otherwise.

- `Finished` - `true` if the referenced node is in `FINISHED` state,
  `false` otherwise.

Predicates on the state of a `NodeList` Node's children:

- `NoChildFailed` - `false` if any child of the referenced Node is in
  `FINISHED` state with an outcome of `FAILURE`, `true` otherwise.

Predicates on the outcome of a Node:

- `Failed` - `true` if the Node is in `FINISHED` state and has an
  outcome of `FAILURE`, false otherwise.
- `Skipped` - `true` if the Node has an outcome of `SKIPPED`, false
  otherwise.
  \note An outcome of `SKIPPED` is only possible if the node is in
  `FINISHED` state.
- `Succeeded` - `true` if the Node is in `FINISHED` state and has an
  outcome of `SUCCESS`, false otherwise.

Predicates on the failure type of a Node:

- `PostConditionFailed` - `true` if the Node has a failure type of
  `POST_CONDITION_FAILED`, `false` otherwise.

Extended %PLEXIL and Standard %PLEXIL add these Node predicates:

- `IterationSucceeded` - `true` if the referenced Node is in
  `ITERATION_ENDED` state and has an outcome of `SUCCESS`, `false`
  otherwise.

- `Interrupted` - `true` if the referenced Node is in `FINISHED`
  state and has an outcome of `INTERRUPTED`, `false` otherwise.

- `IterationFailed` - `true` if the referenced Node is in
  `ITERATION_ENDED` state and has an outcome of `FAILURE`, `false`
  otherwise.

- `InvariantFailed` - `true` if the referenced Node is in `FINISHED`
  state, has an outcome of `FAILURE`, and a failure type of
  `INVARIANT_FAILED`, `false` otherwise.

- `PreconditionFailed` - `true` if the referenced Node is in `FINISHED`
  state, has an outcome of `FAILURE`, and a failure type of
  `PRE_CONDITION_FAILED`, `false` otherwise.

- `ParentFailed` - `true` if the referenced Node is in `FINISHED`
  state, has an outcome of `FAILURE`, and a failure type of
  `PARENT_FAILED`, `false` otherwise.

### Operators

#### Comparison operators

Comparison operators take two operands of various types, as described
below, and return a `Boolean` result.

Note that if either operand to a comparison operator is *unknown*,
the result of the comparison is also *unknown*.

##### (In)Equality comparisons

Because %PLEXIL is strongly statically typed, equality and inequality
comparison operators are also strongly typed.

Standard %PLEXIL automatically translates `==` and `!=` to the
appropriately typed (in)equality operator.

- `EQBoolean`, `NEBoolean` - compare the values of two `Boolean` expressions.
- `EQNumeric`, `NENumeric` - compare the values of two expressions of either
  `Integer` or `Real` type.
- `EQString`, `NEString` - compare the values of two `String` expressions.
- `EQInternal`, `NEInternal` - compare the value of two expressions of internal type.

##### Ordering comparisons

Ordering comparison operators are only implemented for numeric
(i.e. `Integer` or `Real`) expressions at this writing.  A future
%PLEXIL release will extend them to `String` typed expressions.

- `GT` - `true` if the first (left) operand is strictly greater than
  the second (right) operand, `false` if less than or equal.
- `GE` - `true` if the first (left) operand is greater than or equal to
  the second (right) operand, `false` if less than.
- `LT` - `true` if the first (left) operand is strictly less than
  the second (right) operand, `false` if greater than or equal.
- `LE` - `true` if the first (left) operand is less than or equal to
  the second (right) operand, `false` if greater than.

Standard %PLEXIL uses the standard symbols `>`, `>=`, `<`, and `<=`
respectively for these comparison operators.

#### Boolean operators

Boolean operators take `Boolean` typed operands and return a `Boolean`
result.

\note These operators can return *unknown*!

- `NOT` - `true` if its argument evaluates to `false`, and vice
  versa.
- `AND` - takes one or more arguments - `true` if every argument
  evaluates to `true`, `false` if any argument evaluates to `false`,
  *unknown* if no argument evaluates to `false` and any argument is
  *unknown*. 
- `OR` - takes one or more arguments - `true` if any argument
  evaluates to `true`, `false` if every argument evaluates to `false`,
  *unknown* if no argument evaluates to `true` and any argument is
  *unknown*.
- `XOR` - takes one or more arguments - `true` if an odd number of
  arguments evaluate to `true` and the rest to `false`, `false` if an
  even number of arguments evaluate to `true` and the rest to `false`,
  *unknown* if any argument is *unknown*.
  
Standard %PLEXIL accepts the conventional symbols `!`, `&&`, `||`, and `^`
respectively for these operators.

As in C and many other traditional languages, `AND` and `OR` are
*short-circuiting* operators (a.k.a *McCarthy conditionals*); operands
after the first which evaluate to `false` or `true`, respectively, are
not evaluated.

#### Arithmetic operators

#### String operators

There is one operator on `String` valued expressions which returns a
`String`:

- `Concat` - takes one or more arguments - returns the result of
  concatenating all of its arguments' values into a single `String`.
  Standard %PLEXIL uses the `+` sign for the `Concat` operator.
  
There is one operator on a `String` valued expression which returns an
`Integer`:

- `STRLEN` - returns the length in characters of its argument.

### Command return values

### Lookups

## Expressions and notifications

### Active and inactive expressions

