namespace PLEXIL {
/*!

\page lookup-data-flow Data and control flow for %PLEXIL lookups

*Please note that this document describes APIs for lookup handlers
which exist in this form only in %PLEXIL 4.6.  This is one of the
areas in which the %PLEXIL Executive implementation has evolved
significantly over time.  However, the general concepts should be
applicable to all %PLEXIL versions since release 4.0.*

To understand how lookups work in %PLEXIL, it is necessary to
understand (in broad strokes) the execution algorithm as implemented in
the Application Framework.

### The PLEXIL execution algorithm

Here is a simplified view of the plan execution algorithm in the
%PLEXIL Executive Application Framework:

1. The current time is queried and cached, and any data in the
   Executive's *input queue* is processed.  This could include
   external data for lookups, the results of command execution, and/or
   new plans to execute.

2. The updates from step 1 may trigger *change notifications*, which
   propagate throughout the plan(s).  Nodes which receive change
   notifications become candidates for a *node state transition*.  If
   there are no candidate nodes, skip directly to step 8.
   
3. (Start of the *quiescence loop*) The Executive examines the
   candidate nodes and decides which ones will transition, as dictated
   by node state transition rules and conflict resolution logic.
   
4. The legal node state transitions are performed
   (pseudo-)simultaneously.  The state transitions in turn trigger new
   change notifications, which again will make some nodes candidates
   for transition, but those candidates are not processed immediately.
   Steps 3 and 4 together constitute a *micro step*.

5. If the transitions processed in step 4 do not result in any side
   effects (commands, updates, or assignments), but there are
   candidates for state transition, the process repeats from step 3,
   until no further transitions are possible (quiescence is achieved).
   
6. If the transitions in step 4 result in side effects, those actions
   are performed.
   
7. If a micro step completes and there are no further candidates for
   state transition, or if side effects were performed in step 6, a
   *macro step* has been completed.  This is the end of the quiescence
   loop.  Go back to step 1 and repeat the cycle.

8. When a macro step is complete, no nodes are candidates for
   transition, and the input queue is empty, the Executive sleeps
   until the next time it is awakened (e.g. by a timer or external
   event), at which time the process repeats from step 1.

### Two ways to acquire data from a controlled system

The %PLEXIL Executive acquires data from external systems in two ways:

1. The application periodically publishes new data to the Executive by
   calling the virtual function
   AdapterExecInterface::handleValueChange, which enqueues that data
   on the input queue, where it is subsequently processed in step 1 of
   the execution algorithm above.

2. A Lookup expression in the plan queries the system during the
   quiescence loop, as the Executive determines which nodes to
   transition in step 3.  Applications taking this approach must
   implement custom *lookup handlers*.

The periodic publication approach (#1) should be preferred, for these
reasons:

- Approach #2 calls user-developed interface functions from inside the
  most time-critical section of the Executive.  Delays within those
  functions will seriously degrade the responsiveness of the
  Executive.

- Approach #2 exposes some of the more volatile interfacing APIs of
  the %PLEXIL Executive.

- Approach #1 does not require writing lookup handler code, only code
  to scale the data as required, and to reformat the data into
  %PLEXIL's internal representation.  This code would be required in
  either approach.

- Many systems and subsystems publish state data in blocks at regular
  intervals (e.g. telemetry).  Approach #1 is a natural fit for this
  common scenario.

- The APIs for implementing approach #1 are much more likely to be
  stable in subsequent %PLEXIL releases.  We may add convenience
  wrappers for common use cases, but we are unlikely to change the
  existing method prototypes.
  
### Does this application require lookup handlers?

Probably not.

### What happens if a state name is not associated with a lookup handler?

If a state name has no associated lookup handler, the Executive uses
the last value posted to the state cache.

Periodically posting data for that state to the Executive via
AdapterExecInterface::handleValueChange will enqueue the new data, and
input queue processing will subsequently update the cached value.

### When are lookup handlers a valid choice?

User-developed lookup handlers are particularly appropriate:

- When implementing a time interface which schedules wakeups for the
  Executive at intervals determined by a plan.  E.g. the TimeAdapter
  interface provided in the %PLEXIL distribution interprets the upper
  threshold on the 'time' state as the next time at which to wake up
  the Executive.  The TimeAdapterImpl source code can be modified for
  use in enviroments which lack POSIX timer APIs.

- When the system state being queried is particularly volatile and
  time-sensitive.  The Executive queries the handler no more than
  once per macro-step, which limits how rapidly it can track changes
  of an external quantity.  (%PLEXIL is not intended for hard
  real-time control, and cannot guarantee any bounds on response
  time.)
  
- When lookups are used to implement functions not available in
  %PLEXIL (e.g. string processing).
  
This should not be considered an exhaustive list.  There may be other
situations in which a periodic state update is difficult to implement,
inappropriate, or performs suboptimally, and a lookup handler would be
the better choice.

### If you must write lookup handlers

Be aware of these points as you develop lookup handlers for your
application:

- LookupHandler methods are called from within the time-critical
  quiescence loop.  Shorter is better.  If at all possible, keep all
  operations within the Executive's process, and ideally within the
  current thread.  Operations which could incur unbounded delays,
  e.g. remote procedure calls across a wide area network, are
  particularly dangerous in this context.

- Custom handler classes need not implement methods for **any** of the
  virtual member functions defined by LookupHandler.  All have empty
  default methods on the base class.
  
- if a quantity is being published to the Executive on a periodic
  basis, it likely does not need a lookup handler at all.  This is
  easily tested by commenting out the body of the corresponding
  lookupNow method.
  
- setThresholds methods are only applicable to numeric-valued lookups,
  and are ignored for all other data types.
  
- Lookups which require a setThresholds method usually need either a
  Real or an Integer method, but not both.
  
- Even if the application uses LookupOnChange with thresholds, and
  would seem to require setThresholds functionality, activation on
  crossing a threshold is implemented internally in the state cache.
  There may be scenarios where a threshold violation needs to be
  detected and dealt with between periodic updates; however, %PLEXIL
  is likely the wrong tool for those applications.
  
- The only states to date observed to truly require a setThresholds
  method are time states, where the upper threshold is interpreted as
  a timer setting for waking up the Executive.

- Very few, if any, applications will require subscribe and
  unsubscribe methods.  This is part of the reason the virtual
  functions are not included in %PLEXIL 6 and later releases.

- The original motivation for subscribe and unsubscribe methods was
  for use with publish/subscribe interfaces like Data Distribution
  Systems.  Even in that scenario, they may not be appropriate.  These
  methods are generally called in pairs in quick succession, and may
  be called rather frequently if the lookup is in a loop with a short
  cycle time.  Unless bandwidth is a particular concern, or the set of
  states to monitor grows dynamically, it's probably better for the
  application to subscribe to all the data likely to be needed at
  startup, and unsubscribe at shutdown.
  
- Consequently, most applications which use custom lookup handlers
  will only need to implement lookupNow methods or functions.

### Notes and caveats for the periodic update approach

- The AdapterExecInterface API allows for batching of input data.  If
  the application does not run on a fixed cycle time, every batch of
  input data published via AdapterExecInterface::handleValueChange
  should be followed by a call to
  AdapterExecInterface::notifyOfExternalEvent.

- Conversely, if the application wakes up the Executive at regular
  intervals, and should not perform any work between those intervals,
  it will not be necessary or appropriate for the interface to call
  AdapterExecInterface::notifyOfExternalEvent after data batches; that
  function should be called by the periodic wakeup code instead.

- Publishing large numbers of unique State values to the Executive in
  excess of application requirements may result in memory bloat and
  runtime performance issues.  The internal state cache data structure
  uses standard C++ library templates, and has not been particularly
  optimized for space or speed; nor are unused or no-longer-used
  entries deleted during plan execution.

- There is a one-time performance penalty the first time a new State
  is received by the Executive, as the internal representation is
  constructed.  This should only be a concern if the application uses
  many unique State values and/or presumes a particular response time
  bound at startup.

### Key points for interface implementors

- **LookupHandler methods are called from the most time-critical
  sections of the PlexilExec.**  They should return as quickly as
  practicable.  They must not block indefinitely.  Any delays will
  lengthen the response time of the PlexilExec.

- **%Lookup handlers are rarely the most appropriate approach for an
  application.**  Resist the temptation to develop custom lookup
  handlers unless absolutely necessary.

- **It is much safer, and much more efficient, for the controlled
  system to publish periodic state updates, and for the interface to
  periodically pass them to the Executive by calling
  AdapterExecInterface::handleValueChange.**  This approach is a
  natural fit for many control applications.  It has the additional
  advantage that no lookup handlers need be implemented.

[Previous](command-data-flow.html) | [Up](interfacing-tutorial.html) | [Next](listener-data-flow.html)

[Home](index.html)

*/
}
