namespace PLEXIL {
/*!

\page lookup-data-flow Data and control flow for %PLEXIL lookups

*Please be aware that this document describes APIs for lookup handlers
which only apply to the %PLEXIL 4.6 release.  This is one of the areas
in which the %PLEXIL Executive implementation has evolved
significantly over time.  However, the general concepts should be
applicable to all %PLEXIL releases since release 4.0.*

## Two approaches to acquiring data from a controlled system

The %PLEXIL Executive Application Framework supports two approaches to
acquire data from external systems:

1. The *event-driven* approach: The application publishes external
   data to the Executive as it arrives by calling
   AdapterExecInterface::handleValueChange.  When it is time to act on
   that data, the application calls
   AdapterExecInterface::notifyOfExternalEvent, the data received is
   processed, and execution commences.

2. The *demand-pull* approach: A Lookup expression in the plan queries
   the system from the Executive's inner loop, via user-defined
   handlers.

Experience shows that the event-driven approach is generally superior
in practice.

The event-driven approach has these advantages:

- The %PLEXIL execution algorithm itself is event-driven.

- Many systems to be controlled or monitored publish state data in
  fixed size batches at regular intervals (e.g. telemetry).  The
  event-driven approach is a natural fit for this common scenario.
  
- Publishing state updates to the Exec in batches is more efficient
  than acquiring them one at a time on demand.

- The interfacing APIs for event-driven applications are stable.  The
  member functions have been stable since the initial %PLEXIL 4
  release, and are not expected to change significantly in future
  releases.

The demand-pull approach has these disadvantages:

- It calls user-developed interface code from a time-critical routine
  in the Executive core.  Delays within that code will seriously
  degrade the responsiveness of the application.

- External state changes can be missed if the lookupNow handler is not
  called at the appropriate times.  Even %PLEXIL team members have
  been perplexed when plans don't work as expected under this
  approach.

- `LookupOnChange` is extremely unlikely to work as expected in the
  demand-pull approach

- The interfacing APIs are volatile.  The APIs for the demand-pull
  approach have evolved numerous times, including between %PLEXIL
  releases 4.5 and 4.6, and will change again in %PLEXIL 6.

## When is demand-pull an appropriate choice?

The demand-pull approach to implementing lookups is an appropriate
choice:

- When implementing a time interface which schedules wakeups for the
  Executive at intervals determined by a plan.  **This requirement
  dictated the design of the current lookup handler API.**
  
  The TimeAdapter interface provided in the %PLEXIL distribution
  interprets the upper threshold on the 'time' state as the next time
  to wake up the Executive.  The TimeAdapterImpl source code can be
  modified for use in enviroments which lack POSIX timer APIs.
  
  (The TimeAdapter is reimplemented in a different form in PLEXIL 6.)

- When the application only looks up a particular combination of state
  name and parameters once.
  
- When lookups are used to implement functions not available in
  %PLEXIL, and Lookup calls with the same name and parameters will
  always return the same value (e.g. string processing).

This should not be considered an exhaustive list.  But in general,
there are very few cases where the demand-pull approach is a better
fit than the event-driven approach.

## If you must implement the demand-pull approach

%Lookup functionality is implemented by defining methods on classes
derived from the LookupHandler abstract base class, or by defining
handler functions.  The discussion below uses 'handler' as a shorthand
for 'method of a class derived from LookupHandler, or a handler
function'.

Be aware of these points as you develop lookup handlers for your
application:

- Handler methods and/or functions are called from within the
  plan execution loop.  Shorter is better.  If at all possible, keep
  all operations within the Executive's process, and ideally within
  the current thread.  Operations which could incur unbounded delays,
  e.g. remote procedure calls across a wide area network, are
  particularly dangerous in this context and should be avoided.
  
- Handlers are not required for any state published to the Executive
  on a periodic basis.  This can be confirmed easily by commenting out
  the body of the corresponding lookupNow method.
  
- Users need not implement methods for *any* of the virtual member
  functions defined by LookupHandler.  All have empty default methods
  on the base class.  Threshold exceedance detection is built into
  `LookupOnChange`.
  
- There are two ways to implement `LookupOnChange` in the demand-pull
  approach.  Both require a hybrid approach, using the event-driven
  API as well.
  
  The first is to implement a setThresholds handler, *and* when the
  threshold is exceeded, the interface pushes an updated value by
  calling AdapterExecInterface::handleValueChange and
  AdapterExecInterface::notifyOfExternalEvent.
  
  The second, and simpler, approach, is to simply push that state
  value on a periodic basis.  Threshold exceedance detection is built
  into `LookupOnChange`.  There may be scenarios where a threshold
  violation needs to be detected and dealt with between periodic
  updates; however, %PLEXIL is likely the wrong tool for those
  applications.
  
- Given the above, one of the few application scenarios which would
  **require** a setThresholds handler is using `LookupOnChange(time,
  delta)` to schedule Executive wakeups, when the Executive is not
  also awakened on a periodic basis.  In this situation, the upper
  threshold would be interpreted as a timer setting.

- setThresholds handlers are only relevant to numeric-valued lookups,
  and are ignored by the Executive for all other data types.
  
- %Lookups which require a setThresholds handler will need either a
  Real or an Integer variant, but not both.

- Very few, if any, applications will require subscribe and
  unsubscribe methods.  This is part of the reason these functions are
  omitted in the %PLEXIL 6 release.

  The original motivation for subscribe and unsubscribe methods was
  for use with publish/subscribe interfaces (e.g. implementations of
  the OMG DDS standard).  Even then, they may not be appropriate.
  These methods are likely to be called in pairs in quick succession,
  and may be called rather frequently if the node with the lookup is
  in a loop with a short cycle time.
  
  Unless bandwidth is a particular concern, or the set of states to
  monitor grows dynamically, it's probably better for the application
  to subscribe at startup for all the data likely to be needed, and
  unsubscribe at shutdown.

### Notes and caveats for the event-driven approach

Keep these points in mind when implementing event-driven interfaces:

- AdapterExecInterface::handleValueChange only enqueues data.  It does
  not wake up the Executive.  This was a deliberate design choice to
  allow batching of input data for efficiency.  If the application
  needs to act on data received at irregular intervals, publication of
  that data should be immediately followed by a call to
  AdapterExecInterface::notifyOfExternalEvent.

- Conversely, if the application wakes up the Executive at regular
  intervals, and should not perform any work between those intervals,
  it will not be necessary or appropriate for the interface to call
  AdapterExecInterface::notifyOfExternalEvent after data batches.
  That function should be called by the periodic wakeup code instead.

- Try to limit pushing external state data not actually used by the
  application's plans.  Publishing many unique states, in excess of
  the application's requirements, may result in memory bloat and
  runtime performance issues.  The state cache as currently
  implemented uses C++ standard library templates, and has not been
  particularly optimized for space or speed, nor is it garbage
  collected.

### Key points for interface implementors

- **The demand-pull approach is rarely the appropriate approach for an
  application.**  Resist the temptation to use this approach unless
  absolutely necessary.

- **Demand-pull lookup handlers are called from a time-critical
  routine in the Executive core.**  They *should* return as quickly as
  practicable.  They **must not** block indefinitely.  Any delays will
  lengthen the application's response time.

- **If at all possible, use the event-driven approach for
  applications.**  It will ensure more predictable behavior, and is a
  natural fit for many control applications.

[Previous](\ref command-data-flow) | [Up](\ref interfacing-tutorial) | [Next](\ref listener-data-flow)

[Home](index.html)

*/
}
