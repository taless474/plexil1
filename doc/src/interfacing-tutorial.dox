namespace PLEXIL {
/*!
\page interfacing-tutorial Tutorial: Interfacing the %PLEXIL Executive to the outside world

### Overview

This document will attempt to explain the nuts and bolts of
interfacing the %PLEXIL Executive to the outside world using the
[PLEXIL Executive Application Framework](group___app-_framework.html).

Readers should be familiar with C++ programming, and with software
development practices on Linux or macOS systems.

The universalExec executable is based on the ExecApplication class.
universalExec contains everything one would need for a simple %PLEXIL
application, and it can easily be augmented with custom interface
components, such as *interface adapters*, *command handlers*, *lookup
handlers*, and *planner update handlers* tailored to the task at hand.

These custom interface components can be packaged in *shared
libraries* (or *Dynamically Loaded Libraries* in Windows terminology),
to be loaded when the universalExec starts up, as directed by an
*interface configuration file* provided by the user.

For more dedicated applications, the user can build a custom main
program around the ExecApplication class, build in their custom
interface components, and hard-code the startup process to instantiate
and register their custom interfaces.

1. [The PLEXIL Executive algorithm](\ref exec-algorithm)

2. [Interfacing basics](\ref interfacing-basics)

3. [Interface components and their roles](\ref interface-components-roles)

4. [Data and control flow for PLEXIL commands](\ref command-data-flow)

5. [Data and control flow for PLEXIL updates](\ref update-data-flow)

6. [Data and control flow for PLEXIL lookups](\ref lookup-data-flow)

7. [Data and control flow for PLEXIL Exec Listeners](\ref listener-data-flow)

8. [Startup and interface configuration](\ref startup-and-configuration)

[Next](\ref exec-algorithm)

[Home](index.html)

*/
}
