#!/bin/sh
# File: $SVNROOT/scripts/run-agents
# Note: Script to run two Plexil agent systems using IPC

# Copyright (c) 2006-2021, Universities Space Research Association (USRA).
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the Universities Space Research Association nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY USRA ``AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL USRA BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
# TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

debug=

usage ()
{
cat >&2 <<EOF

Usage:      $(basename "$0") [options] <agent1> [-c <config>] [-l <lib>] [-L <lib_dir>] <agent2> [-c <config>] [-l <lib>] [-L <lib_dir>]

Runs two PLEXIL Executives communicating with each other via IPC.

<agent1> and <agent2> are the "base names" of the plans, e.g., "cmd" for cmd.pli
or "t1-sim" for t1-sim.pli.

Options:    -d -debug   := print information about agents prior to starting them
            -dry-run    := display what would be executed, but don't actually execute it
            -i -ipc     := run IPC in an xterm (rather than in the background)
            -n -no-ipc  := do not run IPC at all
            -v -viewer  := start the Plexil Viewer
            -x -xterms  := run the execs in xterms (if your system has them)
            -vx -xv     := start the Viewer and run execs in xterms

Examples:   $(basename "$0") -x sim cmd -l get-int -l get-real

Notes:      Interface configuration file names will be guessed at based on the given
            "base names", e.g., given "t1-cmd" as the base name, "t1-cmd.xml" and "cmd.xml"
            will be tried.

EOF
}

guess_plexil_home()
{
    # This script file is expected to be in $PLEXIL_HOME/scripts
    cd "$(dirname "$(dirname "$(command -v "$0")")")" && pwd -P
}

# Check for PLEXIL_HOME being set, default it if not.
if [ -z "$PLEXIL_HOME" ]
then
    PLEXIL_HOME="$(guess_plexil_home)"
    export PLEXIL_HOME
    echo "Defaulting PLEXIL_HOME to $PLEXIL_HOME"
fi

if [ ! -r "$PLEXIL_HOME/makeinclude/generic-plexil.make" ]
then
    echo "PLEXIL_HOME is set to $PLEXIL_HOME, but I can't find some required files." >&2
    exit 2
fi

# Check that PATH is set correctly
if echo "$PATH" | grep -v "${PLEXIL_HOME}/bin:${PLEXIL_HOME}/scripts"
then
    # shellcheck source=plexil-setup.sh
    . "$PLEXIL_HOME/scripts/plexil-setup.sh"
fi

# Options
debug=
dry_run=
no_ipc=
run_ipc_in_xterm=
use_viewer=
use_xterm=

# Parse command line
while [ -n "$1" ]
do
    case "$1" in
        ( -c )
        if [ -z "$com1" ]
	    then
	        shift
	        com1="$1"
        else
	        shift
	        com2="$1"
        fi
        ;;
        ( -d | -debug )
	    debug=true
        ;;
        ( -dry-run )
        dry_run="$1"
        ;;
        ( -h | -help | --help )
	    usage
	    exit 0
        ;;
        ( -i | -ipc )
	    run_ipc_in_xterm=yes
        ;;
        ( -l )
        # FIXME: Handle lib names wtih spaces
        if [ -z "$agent2_raw" ]
	    then
	        shift
	        libs1="$libs1$1 "
        else
	        shift
	        libs2="$libs2$1 "
        fi
        ;;
        ( -L )
        # FIXME: Handle lib dir names wtih spaces
        if [ -z "$agent2_raw" ]
	    then
	        libdirs1="${libdirs1}$2 "
	        shift
        else
	        libdirs2="${libdirs2}$2 "
	        shift
        fi
        ;;
        ( -n | -no-ipc )
	    no_ipc=yes
        ;;
        ( -v | -viewer )
	    use_viewer=yes
        ;;
        ( -vx | -xv )
	    use_xterm=yes
	    use_viewer=yes
        ;;
        ( -x | -xterm | -xterms )
	    use_xterm=yes
        ;;
        ( * )
        if [ -z "$agent1_raw" ]
	    then
	        agent1_raw="$1"
        elif [ -z "$agent2_raw" ]
	    then
	        agent2_raw="$1"
        else
	        echo "The \"$1\" parameter is ambiguous.  Maybe it is a library missing the -l flag?" >&2
	        usage >&2
	        exit 2
        fi
        ;;
    esac
    shift
done

if [ -z "$agent1_raw" ] || [ -z "$agent2_raw" ] ; then
  echo "$(basename "$0"): Two agents required" >&2
  usage >&2
  exit 2
fi

# Allow for either base names or names including extensions
agent_name()
{
    printf '%s\n' "$1" | awk '{ split($0, arr, "."); print(arr[1]) }'
}

agent1="$(agent_name "$agent1_raw")"
agent2="$(agent_name "$agent2_raw")"

before_dash()
{
    printf '%s\n' "$1" | awk '{ split($0, arr, "-"); print(arr[1]) }'
}

after_dash()
{
    printf '%s\n' "$1" | awk '{ split($0, arr, "-"); print(arr[1]) }'
}

# Look for IPC central process(es).
# Return 0 status if found, 1 if not found.
ipc_running()
{
    # pgrep would be preferable here, but it's not in the POSIX standard.
    # shellcheck disable=SC2009
    ps -A -o pid -o comm | grep -v grep | grep -q 'central'
}

# Determine the interface configuration file for an agent.
# Echo it to stdout if found
# If spec'd on command line and not found, or not spec'd and defaulting fails,
# print error msg to stderr and exit.
# $1 = agent name
# $2 = file spec'd on command line (may be empty)

get_if_config()
{
    if [ -n "$2" ]
    then
       if [ -r "$2" ]
       then
           printf '%s\n' "$2"
           return 0
       elif [ -r "${2}.xml" ]
       then
           printf '%s\n' "${2}.xml"
           return 0
       else
           echo "$(basename "$0"): Error: configuration file not found or not readable;" >&2
           echo " tried both $2 and ${2}.xml" >&2
           exit 2
       fi
    fi
           
    # Guess based on agent name
    if [ -r "${1}.xml" ]
    then
        printf '%s\n' "${1}.xml"
        return 0
    elif [ -r "$(before-dash "$1").xml" ]
    then
        printf '%s\n' "$(before-dash "$1").xml"
        return 0
    elif [ -r "$(after-dash "$1").xml" ]
    then
        printf '%s\n' "$(after-dash "$1").xml"
        return 0
    else
        echo "$(basename "$0"): Error: Unable to find configuration file;" >&2
        echo " tried ${1}.xml, $(before-dash "$1").xml, and $(after-dash "$1").xml" >&2
        echo "Use the -c option to specify it explicitly." >&2
        exit 2
    fi
}

com1="$(get_if_config "$agent1" "$com1")"
com2="$(get_if_config "$agent2" "$com2")"

# For readability
echo ' '

# Try to figure out which make to use
MAKE='make'
if [ "$(uname -s)" = 'FreeBSD' ]
then
    if command -v gmake > /dev/null
    then
	    MAKE='gmake'
    else
	    echo 'ERROR: GNU make not found. Please install it.' >&2
	    exit 2
    fi
fi

# Try to figure out which makefile to use
if [ -r 'makefile' ] ; then
    make_file='makefile'
elif [ -r 'Makefile' ] ; then
    make_file='Makefile'
else
    make_file="$PLEXIL_HOME/makeinclude/generic-plexil.make"
fi

# Keep the plans up-to-date if possible
if [ -n "$dry_run" ]
then
    echo "${MAKE} -f $make_file $agent1.plx $agent2.plx"
else
    ${MAKE} -f "$make_file" "$agent1.plx" "$agent2.plx"
    make_status=$?
    # bail if things don't compile properly
    if [ $make_status != 0 ] ;
    then
        echo "make exited with error status $make_status" >&2
        exit $make_status
    fi
fi

# Find the source file for the given library, if it exists, and write it to stdout.
# $1 = libname w/o extension, optionally w/ directory
# Return 0 status if found, 1 if not found
try_find_source()
{
    for ext in plp ple epx pli plx
    do
        if [ -r "${1}.$ext" ]
        then
            printf '%s\n' "${1}.$ext"
            return 0
        fi
    done
    return 1
}

# Parameters are libname [ libdir ]*
try_find_library_source_on_path()
{
    lib="$(echo "$1" | awk '{ split($0, arr, "."); print(arr[1]) }')"

    # Try working directory first
    if try_find_source "$lib"
    then
        return 0
    fi

    # Try library path
    shift
    while [ -n "$1" ]
    do
        if [ -d "$1" ]
        then
            if try_find_source "${1}/$lib"
            then
                return 0
            fi
        fi
        shift
    done

    echo "Source for library $lib.plx not found" >&2
    exit 2
}

# Ensure library .plx files are up to date 
# $1 = lib name
# Additional args = library directories
ensure_library_file_updated()
{
    lib_src="$(try_find_library_source_on_path "$@")"
    if printf "%s\n" "$lib_src" | grep -qv '\.plx$'
    then
        lib_target="$(printf "%s\n" "$lib_src" | sed -E -e 's/\.(pl[eip]|epx)$/.plx/')"
        if [ -n "$dry_run" ]
        then
            echo "$MAKE -f $make_file $lib_target"
        elif ! ${MAKE} -f "$make_file" "$lib_target"
        then
            # stop if the compile fails
            echo "Error: $lib_src failed to compile" >&2
            exit 1
        fi
    fi
}

# Set up the libraries for inclusion
# FIXME Handle library file, directory names w/ spaces 
for lib in $libs1
do
    # Not quoting libdirs1 is deliberate
    # shellcheck disable=SC2086
    ensure_library_file_updated "$lib" $libdirs1
done
for lib in $libs2
do
    # Not quoting libdirs2 is deliberate
    # shellcheck disable=SC2086
    ensure_library_file_updated "$lib" $libdirs2
done

libopts1="$(for lib in $libs1 ; do printf '%s %s ' '-l' "$lib" ; done ; printf '\n')"
libopts2="$(for lib in $libs2 ; do printf '%s %s ' '-l' "$lib" ; done ; printf '\n')"

libdiropts1="$(for dir in $libdirs1 ; do printf '%s %s ' '-L' "$dir" ; done ; printf '\n')"
libdiropts2="$(for dir in $libdirs2 ; do printf '%s %s ' '-L' "$dir" ; done ; printf '\n')"

# Choose debug configuration files
debug1=
debug2=
if [ -r "${agent1}.cfg" ]
then
    debug1="-d ${agent1}.cfg "
elif [ -r 'Debug.cfg' ]
then
    debug1='-d Debug.cfg '
fi

if [ -r "${agent2}.cfg" ]
then
    debug2="-d ${agent2}.cfg "
elif [ -r 'Debug.cfg' ]
then
    debug2='-d Debug.cfg '
fi

# Set up the sleep time.  Java on Mac OS is really slow,
# hence the long sleep time...
if [ -n "$use_viewer" ] ;
then
    if [ "$(uname)" = 'Darwin' ] ;
    then
        sleep_time=15
    else
        sleep_time=3
    fi
else
    sleep_time=2
fi

# Generate the exec command lines
cmd1="plexilexec ${use_viewer:+'-v -b '}-p ${agent1}.plx -c $com1 ${debug1}${libdiropts1}$libopts1"
cmd2="plexilexec ${use_viewer:+'-v -b '}-p ${agent2}.plx -c $com2 ${debug2}${libdiropts2}$libopts2"

if [ -n "$debug" ] ;
then
    echo ' '
    echo "agent1_raw:   $agent1_raw"
    echo "agent1:       $agent1"
    echo "com1:         $com1"
    echo "libs1:        $libs1"
    echo "libopts1:     $libopts1"
    echo "libdirs1:     $libdirs1"
    echo "libdiropts1:  $libdiropts1"
    echo "debug1:       $debug1"
    echo ' '
    echo "agent2_raw:   $agent2_raw"
    echo "agent2:       $agent2"
    echo "com2:         $com2"
    echo "libs2:        $libs2"
    echo "libopts2:     $libopts2"
    echo "libdirs2:     $libdirs2"
    echo "libdiropts2:  $libdiropts2"
    echo "debug2:       $debug2"
    echo ' '
    echo "PLEXIL_HOME:  $PLEXIL_HOME"
    echo "make_file:    $make_file"
    echo ' '
fi

# Can we use xterm?
if [ -n "${use_xterm}${run_ipc_in_xterm}" ]
then
    if ! command -v xterm > /dev/null
    then
        echo "$(basename "$0"): Error: Use of xterm was requested, but 'xterm' command not found" >&2
        exit 1
    fi
    if [ -z "$DISPLAY" ]
    then
        echo "$(basename "$0"): Error: Use of xterm was requested, but DISPLAY is not set" >&2
        exit 1
    fi
fi

# Has IPC been built?
if test -z "$no_ipc" && ! command -v central > /dev/null
then
    echo "$(basename "$0"): Error: IPC 'central' command not found" >&2
    exit 1
fi

# start IPC/central if necessary
ipc_pid=
if [ -z "$no_ipc" ]
then
    if ! ipc_running
    then
        echo ' '
        echo 'Starting IPC...'
        if [ -n "$run_ipc_in_xterm" ]
        then
            if [ -n "$dry_run" ]
            then
                echo xterm -geometry 172x20+100+100 -T "IPC" central 
            else
                xterm -geometry 172x20+100+100 -T "IPC" central &
                ipc_pid=$!
                echo "Running IPC in xterm (pid: $ipc_pid)..."
            fi
        else
            if [ -n "$dry_run" ]
            then
                echo central -s -u \&
                echo 'Running IPC in the background'
            else
                central -s -u &
                ipc_pid=$!
                echo "Running IPC in the background (pid: $ipc_pid)..."
                echo ' '
            fi
        fi
        test -z "$dry_run" && sleep 3
    else
        echo
        echo 'IPC already running'
        run_ipc_in_xterm=
    fi
fi

# Check that central hasn't crashed before going further
if ! ipc_running
then
    echo "$(basename "$0"): Error: IPC central failed to start up" >&2
    exit 1
fi

# Start the agents
agent1_pid=
echo
echo "$cmd1" \&
echo
if [ -z "$dry_run" ]
then
    if [ -z "$use_xterm" ]
    then
        $cmd1 &
        agent1_pid=$!
    else
        xterm -geometry +200+200 -T "$agent1" -e "$cmd1" &
        agent1_pid=$!
    fi
    sleep $sleep_time
fi

if ! ps "$agent1_pid" > /dev/null
then
    echo "$(basename "$0"): Error: First agent failed to start up" >&2
    exit 1
fi

echo
echo "$cmd2"
echo
if [ -z "$dry_run" ]
then
    if [ -z "$use_xterm" ]
    then
        $cmd2
    else
        xterm -geometry +300+300 -T "$agent2" -e "$cmd2"
    fi
fi

sleep 1

if ps "$agent1_pid" > /dev/null
then
    echo 'Shutting down the first agent...'
    kill "$agent1_pid"
    sleep 1
    if ps "$agent1_pid" > /dev/null
    then
        kill -KILL "$agent1_pid"
    fi
fi

if test -n "$ipc_pid" && ps "$ipc_pid" > /dev/null
then
    echo 'Shutting down IPC...'
    kill "$ipc_pid"
    sleep 1
    if ps "$ipc_pid" > /dev/null
    then
        kill -KILL "$ipc_pid"
    fi
fi

# EOF
